import React, { useState, useCallback, useEffect } from 'react';
import { GoogleGenAI } from "@google/genai";
import { WelcomeScreen } from './components/WelcomeScreen';
import { QuizScreen } from './components/QuizScreen';
import { ResultsScreen } from './components/ResultsScreen';
import { ApiKeyScreen } from './components/ApiKeyScreen';
import { TOPICS, TOTAL_QUESTIONS } from './constants';
import type { QuizQuestion, QuizState, QuizTopic } from './types';

const FullScreenLoader: React.FC<{ text: string }> = ({ text }) => (
    <div className="flex flex-col items-center justify-center text-center animate-fade-in">
        <div className="flex items-center justify-center space-x-2 mb-4">
            <div className="w-6 h-6 rounded-full animate-pulse bg-cyan-400"></div>
            <div className="w-6 h-6 rounded-full animate-pulse bg-cyan-400" style={{ animationDelay: '0.2s' }}></div>
            <div className="w-6 h-6 rounded-full animate-pulse bg-cyan-400" style={{ animationDelay: '0.4s' }}></div>
        </div>
        <p className="text-xl text-slate-300">{text}</p>
    </div>
);


const App: React.FC = () => {
  const [apiKey, setApiKey] = useState<string | null>(null);
  const [quizState, setQuizState] = useState<QuizState>('apikey');
  const [questions, setQuestions] = useState<QuizQuestion[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [score, setScore] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [selectedTopic, setSelectedTopic] = useState<QuizTopic>('telecom');

  useEffect(() => {
    const savedApiKey = localStorage.getItem('geminiApiKey');
    if (savedApiKey) {
      setApiKey(savedApiKey);
      setQuizState('welcome');
    }
  }, []);

  const handleApiKeySubmit = (key: string) => {
    localStorage.setItem('geminiApiKey', key);
    setApiKey(key);
    setQuizState('welcome');
    setError(null);
  };

  const handleClearApiKey = () => {
    localStorage.removeItem('geminiApiKey');
    setApiKey(null);
    setQuizState('apikey');
  };

  const generateQuiz = useCallback(async () => {
    if (!apiKey) {
      setError("API Key is not set.");
      setQuizState('apikey');
      return;
    }

    setQuizState('loading');
    setError(null);
    setQuestions([]);
    setScore(0);
    setCurrentQuestionIndex(0);

    try {
      const ai = new GoogleGenAI({ apiKey });
      const currentTopic = TOPICS[selectedTopic];
      const termList = JSON.stringify(currentTopic.terms.map(t => ({ term: t.term, definition: t.definition })), null, 2);
      const prompt = `
        You are an expert quiz creator specializing in ${currentTopic.name}.
        Your task is to generate ${TOTAL_QUESTIONS} unique multiple-choice questions about this topic.
        Use the provided list of terms as a starting point and inspiration for the types of concepts to cover. If the list is too short, you must generate additional questions and plausible definitions on your own to meet the ${TOTAL_QUESTIONS} requirement.

        Each question must present a term, and the user must select the correct definition from four options.
        - One option must be the correct definition for the given term.
        - The other three options must be plausible but incorrect definitions. These incorrect definitions can be from the provided list or generated by you, but they must be relevant to the topic of ${currentTopic.name}.
        - Ensure the options are different for each question and are shuffled randomly.
        - Do not repeat a term in more than one question.
        
        IMPORTANT: Output EACH question as a single, minified JSON object on a new line. Do not wrap the objects in a JSON array or use markdown backticks like \`\`\`json.
        The JSON object for each question must follow this exact schema:
        {
          "term": "The term for the question",
          "options": ["Definition A", "Definition B", "Definition C", "Definition D"],
          "correctAnswer": "The correct definition string that is also present in the options array",
          "explanation": "A brief, one-sentence explanation of why the correct answer is correct, focusing on the key concept."
        }

        List of terms and definitions for ${currentTopic.name} (use as inspiration):
        ${termList}
      `;
      
      const stream = await ai.models.generateContentStream({
        model: 'gemini-2.5-flash',
        contents: prompt,
      });

      let buffer = '';
      let firstQuestionLoaded = false;

      for await (const chunk of stream) {
          buffer += chunk.text;
          let newlineIndex;
          while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
              const line = buffer.substring(0, newlineIndex).trim();
              buffer = buffer.substring(newlineIndex + 1);

              if (line) {
                  try {
                      const question = JSON.parse(line) as QuizQuestion;
                      setQuestions(prev => [...prev, question]);
                      if (!firstQuestionLoaded) {
                          firstQuestionLoaded = true;
                          setQuizState('active');
                      }
                  } catch (e) {
                      console.warn("Skipping line, failed to parse question JSON:", line, e);
                  }
              }
          }
      }
      
      if (buffer.trim()) {
          try {
              const question = JSON.parse(buffer.trim()) as QuizQuestion;
              setQuestions(prev => [...prev, question]);
              if (!firstQuestionLoaded) {
                  firstQuestionLoaded = true;
                  setQuizState('active');
              }
          } catch (e) {
               console.warn("Skipping remaining buffer, failed to parse question JSON:", buffer, e);
          }
      }

      if (!firstQuestionLoaded) {
          throw new Error("AI failed to generate any valid questions from the stream.");
      }

    } catch (e: any) {
      console.error(e);
      setError(`Failed to generate quiz. Please check your API key and network connection. Details: ${e.message}`);
      setQuizState('welcome');
    }
  }, [apiKey, selectedTopic]);


  const handleAnswer = (isCorrect: boolean) => {
    if (isCorrect) {
      setScore((prevScore) => prevScore + 1);
    }
  };

  const handleNext = () => {
    const nextIndex = currentQuestionIndex + 1;
    if (nextIndex < questions.length) { // Use questions.length to handle cases where fewer questions are generated
      setCurrentQuestionIndex(nextIndex);
    } else {
      setQuizState('results');
    }
  };

  const restartQuiz = () => {
    setQuizState('welcome');
    setQuestions([]);
  };

  const renderContent = () => {
    switch (quizState) {
      case 'apikey':
        return <ApiKeyScreen onApiKeySubmit={handleApiKeySubmit} />;
      case 'welcome':
        return (
          <WelcomeScreen
            onStart={generateQuiz}
            onClearApiKey={handleClearApiKey}
            isLoading={quizState === 'loading'}
            error={error}
            selectedTopic={selectedTopic}
            onTopicChange={setSelectedTopic}
          />
        );
       case 'loading':
        return <FullScreenLoader text="Generating your quiz..." />;
      case 'active':
        const currentQuestion = questions[currentQuestionIndex];
        if (!currentQuestion) {
          return <FullScreenLoader text="Loading next question..." />
        }
        return (
          <QuizScreen
            question={currentQuestion}
            questionNumber={currentQuestionIndex + 1}
            totalQuestions={questions.length} // Use actual number of questions
            onAnswer={handleAnswer}
            onNext={handleNext}
          />
        );
      case 'results':
        return (
          <ResultsScreen
            score={score}
            totalQuestions={questions.length} // Use actual number of questions
            onRestart={restartQuiz}
          />
        );
      default:
        return <WelcomeScreen onStart={generateQuiz} onClearApiKey={handleClearApiKey} isLoading={false} error={error} selectedTopic={selectedTopic} onTopicChange={setSelectedTopic} />;
    }
  };

  return (
    <div className="bg-slate-900 text-white min-h-screen flex items-center justify-center p-4 font-sans">
      <main className="w-full max-w-2xl mx-auto">
        {renderContent()}
      </main>
    </div>
  );
};

export default App;